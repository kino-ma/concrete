//! The public key for homomorphic computation.
//!
//! This module implements the generation of the server's public key, together with all the
//! available homomorphic Boolean gates ($\mathrm{AND}$, $\mathrm{MUX}$, $\mathrm{NAND}$,
//! $\mathrm{NOR}$,
//! $\mathrm{NOT}$, $\mathrm{OR}$, $\mathrm{XNOR}$, $\mathrm{XOR}$).

#[cfg(test)]
mod tests;

use crate::ciphertext::Ciphertext;
use crate::client_key::ClientKey;
use crate::{PLAINTEXT_FALSE, PLAINTEXT_TRUE};
use concrete_core::backends::optalysys::entities::OptalysysFourierLweBootstrapKey32;
use concrete_core::prelude::*;
use serde::{Deserialize, Serialize};
use std::fmt::{Debug, Formatter};

/// A structure containing the server public key.
///
/// The server key is generated by the client and is meant to be published: the client
/// sends it to the server so it can compute homomorphic Boolean circuits.
///
/// In more details, it contains:
/// * `key_switching_key` - a public key, used to perform the key-switching operation.
/// * `bootstrapping_key` - a public key, used to perform the bootstrapping operation.
#[derive(Serialize, Deserialize)]
pub struct ServerKey {
    pub(crate) key_switching_key: LweKeyswitchKey32,
    pub(crate) bootstrapping_key: OptalysysFourierLweBootstrapKey32,
    #[serde(skip, default = "crate::default_engine")]
    pub(crate) engine: DefaultEngine,
    #[serde(skip, default = "crate::optalysys_engine")]
    pub(crate) optalysys_engine: OptalysysEngine,
    pub(crate) accumulator: GlweCiphertext32,
    pub(crate) buffer_lwe_before_pbs: LweCiphertext32,
    pub(crate) buffer_lwe_after_pbs: LweCiphertext32,
}

pub trait BinaryBooleanGates<L, R> {
    fn and(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
    fn nand(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
    fn nor(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
    fn or(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
    fn xor(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
    fn xnor(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
}

impl PartialEq for ServerKey {
    fn eq(&self, other: &Self) -> bool {
        self.key_switching_key == other.key_switching_key
            && self.bootstrapping_key == other.bootstrapping_key
    }
}

impl Debug for ServerKey {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServerKey {{ ")?;
        write!(f, "key_switching_key: {:?}, ", self.key_switching_key)?;
        write!(f, "bootstrapping_key: {:?}, ", self.bootstrapping_key)?;
        write!(f, "engine: DefaultEngine, ")?;
        write!(f, "accumulator: {:?}, ", self.accumulator)?;
        write!(
            f,
            "buffer_lwe_before_pbs: {:?}, ",
            self.buffer_lwe_before_pbs
        )?;
        write!(f, "buffer_lwe_after_pbs: {:?}, ", self.buffer_lwe_after_pbs)?;
        write!(f, "}}")?;
        Ok(())
    }
}

impl Clone for ServerKey {
    fn clone(&self) -> ServerKey {
        let sks_clone: ServerKey = ServerKey {
            key_switching_key: self.key_switching_key.clone(),
            bootstrapping_key: self.bootstrapping_key.clone(),
            accumulator: self.accumulator.clone(),
            buffer_lwe_before_pbs: self.buffer_lwe_before_pbs.clone(),
            buffer_lwe_after_pbs: self.buffer_lwe_after_pbs.clone(),
            engine: crate::default_engine(),
            optalysys_engine: crate::optalysys_engine(),
        };
        sks_clone
    }
}

impl ServerKey {
    /// Allocates and generates a server key.
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::client_key::ClientKey;
    /// use concrete_boolean::parameters::DEFAULT_PARAMETERS;
    /// use concrete_boolean::server_key::ServerKey;
    ///
    /// // Generate the client key:
    /// let cks = ClientKey::new(&DEFAULT_PARAMETERS);
    ///
    /// // Generate the server key:
    /// let sks = ServerKey::new(&cks);
    /// ```
    pub fn new(cks: &ClientKey) -> ServerKey {
        // creation of a core-engine
        let mut engine = super::default_engine();

        // creation of a optalysys-engine
        let mut optalysys_engine = super::optalysys_engine();

        // convert into a variance for rlwe context
        let var_rlwe = Variance(cks.parameters.glwe_modular_std_dev.get_variance());

        // creation of the bootstrapping key in the Fourier domain
        let bsk: LweBootstrapKey32 = engine
            .create_lwe_bootstrap_key(
                &cks.lwe_secret_key,
                &cks.glwe_secret_key,
                cks.parameters.pbs_base_log,
                cks.parameters.pbs_level,
                var_rlwe,
            )
            .unwrap();
        let fourier_bsk: OptalysysFourierLweBootstrapKey32
            = optalysys_engine.convert_lwe_bootstrap_key(&bsk).unwrap();

        // Convert the GLWE secret key into an LWE secret key:
        let big_lwe_secret_key = engine
            .transmute_glwe_secret_key_to_lwe_secret_key(cks.glwe_secret_key.clone())
            .unwrap();

        // convert into a variance for lwe context
        let var_lwe = Variance(cks.parameters.lwe_modular_std_dev.get_variance());

        // creation of the key switching key
        let ksk = engine
            .create_lwe_keyswitch_key(
                &big_lwe_secret_key,
                &cks.lwe_secret_key,
                cks.parameters.ks_level,
                cks.parameters.ks_base_log,
                var_lwe,
            )
            .unwrap();

        // create the accumulator
        let accumulator_u32 = vec![PLAINTEXT_TRUE; fourier_bsk.polynomial_size().0]; // 1/8
                                                                                     // everywhere
        let accumulator_plaintext = engine.create_plaintext_vector(&accumulator_u32).unwrap();
        let accumulator = engine
            .trivially_encrypt_glwe_ciphertext(
                GlweSize(fourier_bsk.glwe_dimension().0 + 1),
                &accumulator_plaintext,
            )
            .unwrap();

        // Allocate the buffer for the input of the PBS
        let zero_plaintext = engine.create_plaintext(&0_u32).unwrap();
        let buffer_lwe_before_pbs = engine
            .trivially_encrypt_lwe_ciphertext(
                LweSize(ksk.output_lwe_dimension().0 + 1),
                &zero_plaintext,
            )
            .unwrap();

        // Allocate the buffer for the output of the PBS
        let zero_plaintext = engine.create_plaintext(&0_u32).unwrap();
        let buffer_lwe_after_pbs = engine
            .trivially_encrypt_lwe_ciphertext(
                LweSize(ksk.input_lwe_dimension().0 + 1),
                &zero_plaintext,
            )
            .unwrap();

        // Pack the keys in the server key set:
        let sks: ServerKey = ServerKey {
            key_switching_key: ksk,
            bootstrapping_key: fourier_bsk,
            engine,
            optalysys_engine,
            accumulator,
            buffer_lwe_before_pbs,
            buffer_lwe_after_pbs,
        };
        sks
    }

    /// function that computes a bootstrap and a keys witch
    fn bootstrap_keyswitch(&mut self) -> Ciphertext {
        // Compute the programmable bootstrapping with fixed test polynomial
        self.optalysys_engine
            .discard_bootstrap_lwe_ciphertext(
                &mut self.buffer_lwe_after_pbs,
                &self.buffer_lwe_before_pbs,
                &self.accumulator,
                &self.bootstrapping_key,
            )
            .unwrap();

        // Allocate the output of the KS
        let zero_plaintext = self.engine.create_plaintext(&0_u32).unwrap();
        let mut ct_ks = self
            .engine
            .trivially_encrypt_lwe_ciphertext(
                LweSize(self.key_switching_key.output_lwe_dimension().0 + 1),
                &zero_plaintext,
            )
            .unwrap();

        // Compute a key switch to get back to input key
        self.engine
            .discard_keyswitch_lwe_ciphertext(
                &mut ct_ks,
                &self.buffer_lwe_after_pbs,
                &self.key_switching_key,
            )
            .unwrap();

        // Result
        Ciphertext(ct_ks)
    }

    /// Computes homomorphically an AND gate between two ciphertexts encrypting Boolean values:
    /// $$ ct_{out} = ct_{left}~\mathrm{AND}~ct_{right} $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::gen_keys;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically an AND gate:
    /// let ct_res = sks.and(&ct1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_and = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_and);
    /// ```
    pub fn and(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        // compute the linear combination for AND: ct_left + ct_right + (0,...,0,-1/8)
        self.engine
            .discard_add_lwe_ciphertext(&mut self.buffer_lwe_before_pbs, &ct_left.0, &ct_right.0)
            .unwrap(); // ct_left + ct_right
        let cst = self.engine.create_plaintext(&PLAINTEXT_FALSE).unwrap();
        self.engine
            .fuse_add_lwe_ciphertext_plaintext(&mut self.buffer_lwe_before_pbs, &cst)
            .unwrap(); //
                       // - 1/8

        // compute the bootstrap and the key switch
        self.bootstrap_keyswitch()
    }

    /// Computes an homomorphic MUX gate between three ciphertexts encrypting Boolean values:
    /// $$ct_{out} = (ct_{condition}?~ct_{then}:~ct_{else}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::gen_keys;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt three messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    /// let ct3 = cks.encrypt(true);
    ///
    /// // Compute homomorphically a MUX gate:
    /// let ct_res = sks.mux(&ct1, &ct2, &ct3);
    ///
    /// // Decrypt:
    /// let dec_mux = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_mux);
    /// ```
    pub fn mux(
        &mut self,
        ct_condition: &Ciphertext,
        ct_then: &Ciphertext,
        ct_else: &Ciphertext,
    ) -> Ciphertext {
        // In theory MUX gate = (ct_condition AND ct_then) + (!ct_condition AND ct_else)

        // Compute the linear combination for first AND: ct_condition + ct_then + (0,...,0,-1/8)
        self.engine
            .discard_add_lwe_ciphertext(
                &mut self.buffer_lwe_before_pbs,
                &ct_condition.0,
                &ct_then.0,
            )
            .unwrap(); // ct_condition + ct_then
        let cst = self.engine.create_plaintext(&PLAINTEXT_FALSE).unwrap();
        self.engine
            .fuse_add_lwe_ciphertext_plaintext(&mut self.buffer_lwe_before_pbs, &cst)
            .unwrap(); //
                       // - 1/8

        // Compute the linear combination for second AND: - ct_condition + ct_else + (0,...,0,-1/8)
        let mut ct_temp_2 = ct_condition.0.clone(); // ct_condition
        self.engine.fuse_opp_lwe_ciphertext(&mut ct_temp_2).unwrap(); // compute the oppation
        self.engine
            .fuse_add_lwe_ciphertext(&mut ct_temp_2, &ct_else.0)
            .unwrap(); // + ct_else
        let cst = self.engine.create_plaintext(&PLAINTEXT_FALSE).unwrap();
        self.engine
            .fuse_add_lwe_ciphertext_plaintext(&mut ct_temp_2, &cst)
            .unwrap(); //
                       // - 1/8

        // Compute the first programmable bootstrapping with fixed test polynomial:
        self.optalysys_engine
            .discard_bootstrap_lwe_ciphertext(
                &mut self.buffer_lwe_after_pbs,
                &self.buffer_lwe_before_pbs,
                &self.accumulator,
                &self.bootstrapping_key,
            )
            .unwrap();

        // Allocate the output of the second PBS:
        let mut ct_pbs_2 = self.buffer_lwe_after_pbs.clone();

        // Compute the second programmable bootstrapping with fixed test polynomial:
        self.optalysys_engine
            .discard_bootstrap_lwe_ciphertext(
                &mut ct_pbs_2,
                &ct_temp_2,
                &self.accumulator,
                &self.bootstrapping_key,
            )
            .unwrap();

        // Compute the linear combination to add the two results : buffer_lwe_pbs + ct_pbs_2 +
        // (0,...,0,
        // +1/8)
        self.engine
            .fuse_add_lwe_ciphertext(&mut self.buffer_lwe_after_pbs, &ct_pbs_2)
            .unwrap(); // + buffer_lwe_pbs
        let cst = self.engine.create_plaintext(&PLAINTEXT_TRUE).unwrap();
        self.engine
            .fuse_add_lwe_ciphertext_plaintext(&mut self.buffer_lwe_after_pbs, &cst)
            .unwrap(); // + 1/8

        // Allocate the output of the KS
        let zero_plaintext = self.engine.create_plaintext(&0_u32).unwrap();
        let mut ct_ks = self
            .engine
            .trivially_encrypt_lwe_ciphertext(
                LweSize(self.key_switching_key.output_lwe_dimension().0 + 1),
                &zero_plaintext,
            )
            .unwrap();

        // Compute the key switch to get back to input key
        self.engine
            .discard_keyswitch_lwe_ciphertext(
                &mut ct_ks,
                &self.buffer_lwe_after_pbs,
                &self.key_switching_key,
            )
            .unwrap();

        // Output the result:
        Ciphertext(ct_ks)
    }

    /// Computes homomorphically a NAND gate between two ciphertexts encrypting Boolean values:
    /// $$ct_{out} = \mathrm{NOT} (ct_{left}~\mathrm{AND}~ct_{right})$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::gen_keys;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically a NAND gate:
    /// let ct_res = sks.nand(&ct1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_nand = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_nand);
    /// ```
    pub fn nand(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        // Compute the linear combination for NAND: - ct_left - ct_right + (0,...,0,1/8)
        self.engine
            .discard_add_lwe_ciphertext(&mut self.buffer_lwe_before_pbs, &ct_left.0, &ct_right.0)
            .unwrap(); // ct_left + ct_right
        self.engine
            .fuse_opp_lwe_ciphertext(&mut self.buffer_lwe_before_pbs)
            .unwrap(); // compute the oppation
        let cst = self.engine.create_plaintext(&PLAINTEXT_TRUE).unwrap();
        self.engine
            .fuse_add_lwe_ciphertext_plaintext(&mut self.buffer_lwe_before_pbs, &cst)
            .unwrap(); // + 1/8

        // compute the bootstrap and the key switch
        self.bootstrap_keyswitch()
    }

    /// Computes homomorphically a NOR gate between two ciphertexts encrypting Boolean values:
    /// $$ ct_{out} = \mathrm{NOT}(ct_{left}~\mathrm{OR}~ct_{right}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::gen_keys;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically the NOR gate:
    /// let ct_res = sks.nor(&ct1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_nor = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_nor);
    /// ```
    pub fn nor(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        // Compute the linear combination for NOR: - ct_left - ct_right + (0,...,0,-1/8)
        self.engine
            .discard_add_lwe_ciphertext(&mut self.buffer_lwe_before_pbs, &ct_left.0, &ct_right.0)
            .unwrap(); // ct_left + ct_right
        self.engine
            .fuse_opp_lwe_ciphertext(&mut self.buffer_lwe_before_pbs)
            .unwrap(); // compute the oppation
        let cst = self.engine.create_plaintext(&PLAINTEXT_FALSE).unwrap();
        self.engine
            .fuse_add_lwe_ciphertext_plaintext(&mut self.buffer_lwe_before_pbs, &cst)
            .unwrap(); //
                       // - 1/8

        // compute the bootstrap and the key switch
        self.bootstrap_keyswitch()
    }

    /// Computes homomorphically a NOT gate of a ciphertexts encrypting a Boolean value:
    /// $$ct_{out} = \mathrm{NOT}(ct_{in})$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::gen_keys;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt a message:
    /// let ct = cks.encrypt(true);
    ///
    /// // Compute homomorphically a NOT gate:
    /// let ct_res = sks.not(&ct);
    ///
    /// // Decrypt:
    /// let dec_not = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_not);
    /// ```
    pub fn not(&mut self, ct: &Ciphertext) -> Ciphertext {
        // Compute the linear combination for NOT: -ct
        let mut ct_res = ct.0.clone();
        self.engine.fuse_opp_lwe_ciphertext(&mut ct_res).unwrap(); // compute the oppation

        // Output the result:
        Ciphertext(ct_res)
    }

    /// Computes homomorphically an OR gate between two ciphertexts encrypting Boolean values:
    /// $$ct_{out} = ct_{left}~\mathrm{OR}~ct_{right}$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::gen_keys;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically the OR gate:
    /// let ct_res = sks.or(&ct1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_or = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_or);
    /// ```
    pub fn or(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        // Compute the linear combination for OR: ct_left + ct_right + (0,...,0,+1/8)
        self.engine
            .discard_add_lwe_ciphertext(&mut self.buffer_lwe_before_pbs, &ct_left.0, &ct_right.0)
            .unwrap(); // ct_left + ct_right
        let cst = self.engine.create_plaintext(&PLAINTEXT_TRUE).unwrap();
        self.engine
            .fuse_add_lwe_ciphertext_plaintext(&mut self.buffer_lwe_before_pbs, &cst)
            .unwrap(); // + 1/8

        // compute the bootstrap and the key switch
        self.bootstrap_keyswitch()
    }

    /// Computes homomorphically an XNOR gate (or equality test) between two ciphertexts encrypting
    /// Boolean values:
    /// $$ct_{out} = (ct_{left}~==~ct_{right}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::gen_keys;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute the XNOR gate:
    /// let ct_res = sks.xnor(&ct1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_xnor = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_xnor);
    /// ```
    pub fn xnor(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        // Compute the linear combination for XNOR: 2*(-ct_left - ct_right + (0,...,0,-1/8))
        self.engine
            .discard_add_lwe_ciphertext(&mut self.buffer_lwe_before_pbs, &ct_left.0, &ct_right.0)
            .unwrap(); // ct_left + ct_right
        let cst_add = self.engine.create_plaintext(&PLAINTEXT_TRUE).unwrap();
        self.engine
            .fuse_add_lwe_ciphertext_plaintext(&mut self.buffer_lwe_before_pbs, &cst_add)
            .unwrap(); // + 1/8
        self.engine
            .fuse_opp_lwe_ciphertext(&mut self.buffer_lwe_before_pbs)
            .unwrap(); // compute the oppation
        let cst_mul = self.engine.create_cleartext(&2u32).unwrap();
        self.engine
            .fuse_mul_lwe_ciphertext_cleartext(&mut self.buffer_lwe_before_pbs, &cst_mul)
            .unwrap(); //* 2

        // compute the bootstrap and the key switch
        self.bootstrap_keyswitch()
    }

    /// Computes homomorphically an XOR gate between two ciphertexts encrypting Boolean values:
    /// $$ct_{out}= ct_{left}~\mathrm{XOR}~ct_{right}$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::gen_keys;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encryption of two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute the XOR gate:
    /// let ct_res = sks.xor(&ct1, &ct2);
    ///
    /// // Decryption:
    /// let dec_xor = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_xor);
    /// ```
    pub fn xor(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        // Compute the linear combination for XOR: 2*(ct_left + ct_right) + (0,...,0,1/4)
        self.engine
            .discard_add_lwe_ciphertext(&mut self.buffer_lwe_before_pbs, &ct_left.0, &ct_right.0)
            .unwrap(); // ct_left + ct_right
        let cst_add = self.engine.create_plaintext(&PLAINTEXT_TRUE).unwrap();
        self.engine
            .fuse_add_lwe_ciphertext_plaintext(&mut self.buffer_lwe_before_pbs, &cst_add)
            .unwrap(); // + 1/8
        let cst_mul = self.engine.create_cleartext(&2u32).unwrap();
        self.engine
            .fuse_mul_lwe_ciphertext_cleartext(&mut self.buffer_lwe_before_pbs, &cst_mul)
            .unwrap(); //* 2

        // compute the bootstrap and the key switch
        self.bootstrap_keyswitch()
    }
}
